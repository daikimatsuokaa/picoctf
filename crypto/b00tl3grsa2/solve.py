from Crypto.Util.number import long_to_bytes
from sage.all import *

def wiener(e, n):
    # Convert e/n into a continued fraction
    cf = continued_fraction(e/n)
    convergents = cf.convergents()
    for kd in convergents:
        k = kd.numerator()
        d = kd.denominator()
        # Check if k and d meet the requirements
        if k == 0 or d%2 == 0 or e*d % k != 1:
            continue
        phi = (e*d - 1)/k
        # Create the polynomial
        x = PolynomialRing(RationalField(), 'x').gen()
        f = x**2 - (n-phi+1)*x + n
        roots = f.roots()
        # Check if polynomial as two roots
        if len(roots) != 2:
            continue
        # Check if roots of the polynomial are p and q
        p,q = int(roots[0][0]), int(roots[1][0])
        if p*q == n:
            return d
    return None
# Test to see if our attack works
if __name__ == '__main__':
    c = 100409925070888971426957876309967957536389433170058011600814709171101996129702179944310758956656188785699266394157143798654447464896702264296940175386664619597004197514193786788091235900765499986696986750579383796711856573575696387015694095246781438121434578602043105404098909458764373781762276806747255065146
    n = 121807897516429986294011812281658981244321428555964428984498908921074927119646327288411543371567388937017355120342715726291275581207358317464368447188369488815377280502493636155508078158435760389139274693400050762236611972012056529525193134731492456705732849204537707975292277682245862837377469637511450307077
    e = 81219514374635304805865727526377707575806065374782025149055004363062899433929304914419275123886099900189532651843330248915916987704355571888787048135931722948325679801088876863637881165000209057232199615182361670032315057593667697167430418733461214911896752204977458043441352565609872119840454792596879619653
    d = wiener(e,n)
    assert not d is None, "Wiener's attack failed :("
    print(long_to_bytes(int(pow(c,d,n))).decode())